<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéØ AI Go Tutor - Live OGS Monitoring</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 400px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .game-board {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .tutor-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            max-height: 600px;
            overflow-y: auto;
        }

        .connection-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            margin-bottom: 20px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected { background: #28a745; }
        .status-connecting { background: #ffc107; }
        .status-disconnected { background: #dc3545; }

        .board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .go-board {
            width: 100%;
            height: 500px;
            background: #deb887;
            border: 3px solid #8b7355;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }

        .go-board:hover {
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
        }

        .go-board.manual-mode {
            cursor: crosshair !important;
        }

        .hover-stone {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #333;
            transform: translate(-50%, -50%);
            z-index: 8;
            opacity: 0.5;
            pointer-events: none;
        }

        .hover-stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #000);
        }

        .hover-stone.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
        }

        .board-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .grid-line {
            position: absolute;
            background: #333;
        }

        .grid-line.horizontal {
            height: 1px;
            width: 90%;
            left: 5%;
        }

        .grid-line.vertical {
            width: 1px;
            height: 90%;
            top: 5%;
        }

        .stone {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 1px solid #333;
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        .stone.black {
            background: radial-gradient(circle at 30% 30%, #555, #000);
        }

        .stone.white {
            background: radial-gradient(circle at 30% 30%, #fff, #ddd);
        }

        .stone.last-move {
            box-shadow: 0 0 0 3px #ff4444;
        }

        .star-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        .input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
        }

        .input-group input {
            flex: 1;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .tutoring-message {
            background: #f8f9fa;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
        }

        .tutoring-message h4 {
            color: #007bff;
            margin-bottom: 10px;
        }

        .game-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .info-card h3 {
            color: #333;
            margin-bottom: 5px;
        }

        .info-card p {
            color: #666;
            font-size: 18px;
            font-weight: bold;
        }

        .move-history {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
            max-height: 200px;
            overflow-y: auto;
        }

        .move-history h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .move-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 5px;
        }

        .move-item {
            padding: 5px;
            background: white;
            border-radius: 5px;
            text-align: center;
            font-size: 12px;
            border: 1px solid #ddd;
        }

        .move-item.black {
            background: #333;
            color: white;
        }

        .move-item.white {
            background: #fff;
            color: #333;
        }

        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .log-panel {
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 14px;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-success { color: #2ecc71; }
        .log-error { color: #e74c3c; }
        .log-warning { color: #f39c12; }
        .log-info { color: #3498db; }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .game-info {
                grid-template-columns: 1fr;
            }
        }

        .pulse {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .slide-in {
            animation: slideIn 0.5s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ AI Go Tutor</h1>
            <p>Live OGS Game Monitoring & Analysis</p>
        </div>

        <!-- Connection Panel -->
        <div class="connection-panel">
            <h3><span id="connection-status" class="status-indicator status-disconnected"></span>OGS Connection</h3>
            
            <div class="input-group">
                <input type="text" id="username" placeholder="OGS Username" value="Mohammad Awad">
                <input type="password" id="password" placeholder="OGS Password" value="">
                <button class="btn btn-primary" onclick="connectToOGS()">Connect</button>
            </div>
            
            <div class="input-group">
                <input type="text" id="game-id" placeholder="Game ID (optional)" value="">
                <button class="btn btn-success" onclick="monitorGame()">Monitor Game</button>
                <button class="btn btn-danger" onclick="stopMonitoring()">Stop</button>
            </div>
            
            <div class="controls">
                <button class="btn btn-primary" onclick="startDemo()">Demo Mode</button>
                <button class="btn btn-primary" onclick="clearLog()">Clear Log</button>
                <button class="btn btn-primary" onclick="clearGame()">New Game</button>
                <label>
                    <input type="checkbox" id="auto-tutor" checked> Auto-Tutoring
                </label>
                <label>
                    <input type="checkbox" id="manual-mode"> Manual Play Mode
                </label>
                <label>
                    <input type="checkbox" id="auto-opponent" checked> Auto Opponent
                </label>
                <label>
                    Tutor every <input type="number" id="tutor-interval" value="2" min="1" max="10" style="width: 50px;"> moves
                </label>
            </div>
        </div>

        <div class="main-grid">
            <!-- Game Board -->
            <div class="game-board">
                <div class="game-info">
                    <div class="info-card">
                        <h3>Move Count</h3>
                        <p id="move-count">0</p>
                    </div>
                    <div class="info-card">
                        <h3>Current Turn</h3>
                        <p id="current-turn">Black</p>
                    </div>
                    <div class="info-card">
                        <h3>Game Phase</h3>
                        <p id="game-phase">Opening</p>
                    </div>
                    <div class="info-card">
                        <h3>Mode</h3>
                        <p id="game-mode">Monitoring</p>
                    </div>
                </div>

                <div class="board-container">
                    <div class="go-board" id="go-board">
                        <!-- Board will be generated by JavaScript -->
                    </div>
                    
                    <!-- Manual Controls -->
                    <div style="text-align: center; margin-top: 15px;">
                        <button class="btn btn-success" id="opponent-move-btn" onclick="playOpponentMove()" disabled>
                            ü§ñ Opponent Move
                        </button>
                        <button class="btn btn-primary" onclick="requestTutoring()">
                            üéì Get Tutoring
                        </button>
                        <button class="btn btn-danger" onclick="testOpponent()" style="font-size: 12px;">
                            üîß Test
                        </button>
                    </div>
                </div>

                <div class="move-history">
                    <h3>Move History</h3>
                    <div class="move-list" id="move-list">
                        <!-- Moves will be added here -->
                    </div>
                </div>
            </div>

            <!-- AI Tutor Panel -->
            <div class="tutor-panel">
                <h3>üéì AI Tutor Analysis</h3>
                <div id="tutoring-content">
                    <div class="tutoring-message">
                        <h4>Welcome to AI Go Tutor! üéØ</h4>
                        <p>Connect to an OGS game or start demo mode to begin receiving AI tutoring advice.</p>
                        
                        <h4>Features:</h4>
                        <ul>
                            <li>üìä Real-time position analysis</li>
                            <li>üìö Joseki pattern recognition</li>
                            <li>üîç Tactical pattern detection</li>
                            <li>ü§î Socratic learning questions</li>
                            <li>üìà Move-by-move guidance</li>
                        </ul>
                        
                        <p><strong>Get started:</strong> Enter your OGS credentials and click Connect!</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="log-panel">
            <h3>üîç System Log</h3>
            <div id="log-content">
                <div class="log-entry log-info">System initialized. Ready to connect to OGS.</div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let gameState = {
            connected: false,
            monitoring: false,
            moves: [],
            currentTurn: 'black',
            aiTutor: null,
            moveCount: 0,
            gamePhase: 'Opening'
        };

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            initializeBoard();
            log('Application loaded successfully', 'success');
            
            // Add event listeners
            document.getElementById('manual-mode').addEventListener('change', function() {
                updateGameInfo();
                if (this.checked) {
                    log('Manual play mode enabled - click on board to place stones', 'info');
                } else {
                    log('Manual play mode disabled', 'info');
                    clearHoverStone();
                }
            });
            
            document.getElementById('auto-opponent').addEventListener('change', function() {
                if (this.checked) {
                    log('Auto-opponent enabled', 'info');
                } else {
                    log('Auto-opponent disabled - use manual button', 'info');
                }
            });
            
            // Initialize game info
            updateGameInfo();
        });

        // Initialize the Go board
        function initializeBoard() {
            const board = document.getElementById('go-board');
            board.innerHTML = '';

            // Create grid lines
            for (let i = 0; i < 19; i++) {
                // Horizontal lines
                const hLine = document.createElement('div');
                hLine.className = 'grid-line horizontal';
                hLine.style.top = `${5 + (i * 90/18)}%`;
                board.appendChild(hLine);

                // Vertical lines
                const vLine = document.createElement('div');
                vLine.className = 'grid-line vertical';
                vLine.style.left = `${5 + (i * 90/18)}%`;
                board.appendChild(vLine);
            }

            // Add star points (handicap points)
            const starPoints = [
                [3, 3], [9, 3], [15, 3],
                [3, 9], [9, 9], [15, 9],
                [3, 15], [9, 15], [15, 15]
            ];

            starPoints.forEach(([x, y]) => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.left = `${5 + (x * 90/18)}%`;
                star.style.top = `${5 + (y * 90/18)}%`;
                board.appendChild(star);
            });

            // Add click handler for manual move placement
            board.addEventListener('click', handleBoardClick);
            board.addEventListener('mousemove', handleBoardHover);
            board.addEventListener('mouseleave', clearHoverStone);
            board.style.cursor = 'pointer';
        }

        // Handle board hover for preview stone
        function handleBoardHover(event) {
            const manualMode = document.getElementById('manual-mode').checked;
            if (!manualMode) return;

            const board = event.currentTarget;
            const rect = board.getBoundingClientRect();
            
            // Calculate hover position
            const x = (event.clientX - rect.left) / rect.width;
            const y = (event.clientY - rect.top) / rect.height;
            
            // Convert to board coordinates
            const boardX = Math.round((x - 0.05) * 18 / 0.9);
            const boardY = Math.round((y - 0.05) * 18 / 0.9);
            
            // Check if coordinates are valid
            if (boardX < 0 || boardX > 18 || boardY < 0 || boardY > 18) {
                clearHoverStone();
                return;
            }
            
            // Check if position is occupied
            if (isPositionOccupied(boardX, boardY)) {
                clearHoverStone();
                return;
            }
            
            // Show hover stone
            showHoverStone(boardX, boardY, gameState.currentTurn);
        }

        // Show hover stone preview
        function showHoverStone(x, y, color) {
            clearHoverStone();
            
            const board = document.getElementById('go-board');
            const hoverStone = document.createElement('div');
            hoverStone.className = `hover-stone ${color}`;
            hoverStone.id = 'hover-stone';
            hoverStone.style.left = `${5 + (x * 90/18)}%`;
            hoverStone.style.top = `${5 + (y * 90/18)}%`;
            
            board.appendChild(hoverStone);
        }

        // Clear hover stone
        function clearHoverStone() {
            const hoverStone = document.getElementById('hover-stone');
            if (hoverStone) {
                hoverStone.remove();
            }
        }

        // Handle board clicks for manual move placement
        function handleBoardClick(event) {
            // Only allow clicks in manual mode
            if (gameState.monitoring && !document.getElementById('manual-mode').checked) {
                log('Board locked during monitoring. Enable manual mode to place moves.', 'warning');
                return;
            }

            const board = event.currentTarget;
            const rect = board.getBoundingClientRect();
            
            // Calculate click position relative to board
            const x = (event.clientX - rect.left) / rect.width;
            const y = (event.clientY - rect.top) / rect.height;
            
            // Convert to board coordinates (0-18)
            const boardX = Math.round((x - 0.05) * 18 / 0.9);
            const boardY = Math.round((y - 0.05) * 18 / 0.9);
            
            // Check if coordinates are valid
            if (boardX < 0 || boardX > 18 || boardY < 0 || boardY > 18) {
                return;
            }
            
            // Check if position is already occupied
            if (isPositionOccupied(boardX, boardY)) {
                log(`Position already occupied!`, 'warning');
                return;
            }
            
            // Convert to coordinate string
            const letters = "ABCDEFGHJKLMNOPQRST";
            const coordinate = letters[boardX] + (boardY + 1);
            
            // Place stone
            const color = gameState.currentTurn;
            log(`Manual move: ${coordinate} (${color})`, 'info');
            addMoveToGame(coordinate, color);
        }

        // Check if position is occupied
        function isPositionOccupied(x, y) {
            return gameState.moves.some(move => {
                const coords = parseCoordinate(move.coordinate);
                return coords && coords.x === x && coords.y === y;
            });
        }

        // Connect to OGS
        async function connectToOGS() {
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!username || !password) {
                log('Please enter username and password', 'error');
                return;
            }

            updateConnectionStatus('connecting');
            log(`Attempting to connect as ${username}...`, 'info');

            try {
                // Simulate connection (in real implementation, this would call your Python backend)
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                gameState.connected = true;
                updateConnectionStatus('connected');
                log(`Successfully connected as ${username}!`, 'success');
                
                // Auto-find games
                setTimeout(findLiveGames, 1000);
                
            } catch (error) {
                log(`Connection failed: ${error.message}`, 'error');
                updateConnectionStatus('disconnected');
            }
        }

        // Monitor a specific game
        async function monitorGame() {
            if (!gameState.connected) {
                log('Please connect to OGS first', 'error');
                return;
            }

            const gameId = document.getElementById('game-id').value;
            
            if (gameId) {
                log(`Starting to monitor game ${gameId}...`, 'info');
            } else {
                log('Monitoring any available live game...', 'info');
            }

            gameState.monitoring = true;
            
            // Simulate monitoring (in real implementation, this would connect to websocket)
            simulateGameMonitoring();
        }

        // Stop monitoring
        function stopMonitoring() {
            gameState.monitoring = false;
            log('Stopped monitoring games', 'warning');
        }

        // Start demo mode
        function startDemo() {
            log('Starting demo mode...', 'info');
            gameState.monitoring = true;
            
            // Clear current game
            clearGame();
            
            // Start demo game
            simulateDemoGame();
        }

        // Find live games
        async function findLiveGames() {
            log('Searching for live games...', 'info');
            
            // Simulate finding games
            await new Promise(resolve => setTimeout(resolve, 1500));
            
            log('Found 3 live games available for monitoring', 'success');
            log('Game 12345678: Player1 vs Player2', 'info');
            log('Game 87654321: Player3 vs Player4', 'info');
            log('Game 11223344: Player5 vs Player6', 'info');
        }

        // Simulate game monitoring
        function simulateGameMonitoring() {
            if (!gameState.monitoring) return;

            const moves = [
                'D4', 'Q16', 'D16', 'Q4', 'C6', 'R14', 'F3', 'Q14',
                'Q6', 'O17', 'R6', 'R17', 'C10', 'P3', 'O4', 'N3'
            ];

            let moveIndex = 0;
            
            const playMove = () => {
                if (!gameState.monitoring || moveIndex >= moves.length) return;
                
                const move = moves[moveIndex];
                const color = moveIndex % 2 === 0 ? 'black' : 'white';
                
                log(`Move ${moveIndex + 1}: ${move} (${color})`, 'info');
                addMoveToGame(move, color);
                
                moveIndex++;
                
                // Continue with next move
                if (gameState.monitoring && moveIndex < moves.length) {
                    setTimeout(playMove, 3000 + Math.random() * 2000); // Random delay 3-5 seconds
                }
            };

            // Start playing moves
            setTimeout(playMove, 2000);
        }

        // Simulate demo game
        function simulateDemoGame() {
            const demoMoves = [
                'D4', 'Q16', 'D16', 'Q4', 'C6', 'R14', 'F3', 'Q14', 'Q6', 'O17'
            ];

            let moveIndex = 0;
            
            const playDemoMove = () => {
                if (!gameState.monitoring || moveIndex >= demoMoves.length) return;
                
                const move = demoMoves[moveIndex];
                const color = moveIndex % 2 === 0 ? 'black' : 'white';
                
                addMoveToGame(move, color);
                
                moveIndex++;
                
                if (gameState.monitoring && moveIndex < demoMoves.length) {
                    setTimeout(playDemoMove, 2000);
                }
            };

            setTimeout(playDemoMove, 1000);
        }

        // Add move to game
        function addMoveToGame(coordinate, color) {
            const move = {
                coordinate: coordinate,
                color: color,
                moveNumber: gameState.moves.length + 1
            };
            
            gameState.moves.push(move);
            gameState.moveCount = gameState.moves.length;
            gameState.currentTurn = color === 'black' ? 'white' : 'black';
            
            // Update UI
            updateGameInfo();
            addStoneToBoard(coordinate, color, true);
            addMoveToHistory(move);
            
            // Update opponent button
            updateOpponentButton();
            
            // Provide tutoring if enabled
            const autoTutor = document.getElementById('auto-tutor').checked;
            const interval = parseInt(document.getElementById('tutor-interval').value);
            
            if (autoTutor && gameState.moveCount % interval === 0) {
                setTimeout(() => provideTutoring(move), 500);
            }
            
            // Auto-opponent response (only if enabled)
            const manualMode = document.getElementById('manual-mode').checked;
            const autoOpponent = document.getElementById('auto-opponent').checked;
            
            if (manualMode && autoOpponent && !gameState.monitoring) {
                // Opponent plays after 1-2 seconds
                setTimeout(() => {
                    if (gameState.currentTurn !== color) { // Make sure turn hasn't changed
                        playOpponentMove();
                    }
                }, 1000 + Math.random() * 1000);
            }
        }

        // Update opponent button state
        function updateOpponentButton() {
            const button = document.getElementById('opponent-move-btn');
            const manualMode = document.getElementById('manual-mode').checked;
            
            if (manualMode && !gameState.monitoring && gameState.moveCount > 0) {
                button.disabled = false;
                button.textContent = `ü§ñ ${gameState.currentTurn.charAt(0).toUpperCase() + gameState.currentTurn.slice(1)} Move`;
            } else {
                button.disabled = true;
                button.textContent = 'ü§ñ Opponent Move';
            }
        }

        // AI opponent plays a move (fixed version)
        function playOpponentMove() {
            console.log("playOpponentMove called"); // Debug log
            
            if (gameState.moveCount === 0) {
                log('No moves played yet', 'warning');
                return;
            }
            
            const opponentColor = gameState.currentTurn;
            log(`Generating ${opponentColor} move...`, 'info');
            
            const move = generateOpponentMove();
            
            if (move) {
                log(`AI Opponent plays: ${move} (${opponentColor})`, 'success');
                addMoveToGame(move, opponentColor);
            } else {
                log('Could not generate opponent move', 'error');
            }
        }

        // Generate opponent move (improved version)
        function generateOpponentMove() {
            console.log("generateOpponentMove called"); // Debug log
            console.log("Current moves:", gameState.moves); // Debug log
            
            const occupiedPositions = new Set();
            
            // Track occupied positions
            gameState.moves.forEach(move => {
                occupiedPositions.add(move.coordinate);
            });
            
            console.log("Occupied positions:", Array.from(occupiedPositions)); // Debug log
            
            // Strategic move selection based on game phase
            let candidateMoves = [];
            
            if (gameState.moveCount < 8) {
                // Opening: prefer corners and star points
                candidateMoves = ['D4', 'Q16', 'D16', 'Q4', 'D10', 'Q10', 'K4', 'K16', 'C6', 'F3', 'R14', 'O17'];
                console.log("Opening moves:", candidateMoves);
            } else if (gameState.moveCount < 40) {
                // Early middle game: approaches and extensions
                candidateMoves = [
                    'C6', 'F3', 'R14', 'O17', 'C14', 'F17', 'R6', 'O3',
                    'K4', 'K16', 'D10', 'Q10', 'J3', 'J17', 'C10', 'R10',
                    'E3', 'E17', 'O4', 'O16', 'G3', 'G17', 'M3', 'M17'
                ];
                console.log("Middle game moves:", candidateMoves);
            } else {
                // Later game: generate some random moves
                candidateMoves = [];
                const letters = "ABCDEFGHJKLMNOPQRST";
                
                // Generate moves avoiding edges
                for (let x = 2; x < 17; x++) {
                    for (let y = 3; y < 17; y++) {
                        candidateMoves.push(letters[x] + y);
                    }
                }
                console.log("Late game moves generated:", candidateMoves.length);
            }
            
            // Filter out occupied positions
            const availableMoves = candidateMoves.filter(move => !occupiedPositions.has(move));
            console.log("Available moves:", availableMoves);
            
            if (availableMoves.length > 0) {
                const selectedMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                console.log("Selected move:", selectedMove);
                return selectedMove;
            }
            
            // Fallback: find any empty position
            console.log("Fallback: searching for empty position");
            const letters = "ABCDEFGHJKLMNOPQRST";
            for (let attempts = 0; attempts < 100; attempts++) {
                const x = Math.floor(Math.random() * 19);
                const y = Math.floor(Math.random() * 19);
                const coord = letters[x] + (y + 1);
                
                if (!occupiedPositions.has(coord)) {
                    console.log("Fallback move found:", coord);
                    return coord;
                }
            }
            
            console.log("No move found!");
            return null; // Board full or error
        }

        // Generate approach moves
        function generateApproachMoves() {
            return [
                'C6', 'F3', 'R14', 'O17', 'C14', 'F17', 'R6', 'O3',
                'K4', 'K16', 'D10', 'Q10', 'J3', 'J17', 'C10', 'R10'
            ];
        }

        // Generate random strategic moves
        function generateRandomMoves() {
            const moves = [];
            const letters = "ABCDEFGHJKLMNOPQRST";
            
            // Generate moves avoiding edges (too close to border)
            for (let x = 2; x < 17; x++) {
                for (let y = 3; y < 17; y++) {
                    if (Math.random() > 0.85) { // Only add 15% of positions
                        moves.push(letters[x] + y);
                    }
                }
            }
            
            return moves.slice(0, 20); // Limit to 20 candidates
        }

        // Add stone to visual board
        function addStoneToBoard(coordinate, color, isLastMove = false) {
            const coords = parseCoordinate(coordinate);
            if (!coords) return;
            
            const board = document.getElementById('go-board');
            
            // Remove previous last-move highlight
            const stones = board.querySelectorAll('.stone');
            stones.forEach(stone => stone.classList.remove('last-move'));
            
            const stone = document.createElement('div');
            stone.className = `stone ${color}`;
            if (isLastMove) {
                stone.classList.add('last-move');
            }
            
            stone.style.left = `${5 + (coords.x * 90/18)}%`;
            stone.style.top = `${5 + (coords.y * 90/18)}%`;
            
            board.appendChild(stone);
        }

        // Parse coordinate like "D4" to {x: 3, y: 3}
        function parseCoordinate(coord) {
            if (coord.length < 2) return null;
            
            const letters = "ABCDEFGHJKLMNOPQRST";
            const letter = coord[0].toUpperCase();
            const number = parseInt(coord.slice(1));
            
            const x = letters.indexOf(letter);
            const y = number - 1;
            
            if (x >= 0 && x < 19 && y >= 0 && y < 19) {
                return { x, y };
            }
            
            return null;
        }

        // Add move to history
        function addMoveToHistory(move) {
            const moveList = document.getElementById('move-list');
            
            const moveItem = document.createElement('div');
            moveItem.className = `move-item ${move.color}`;
            moveItem.textContent = `${move.moveNumber}. ${move.coordinate}`;
            
            moveList.appendChild(moveItem);
            
            // Scroll to bottom
            moveList.scrollTop = moveList.scrollHeight;
        }

        // Request tutoring manually
        function requestTutoring() {
            if (gameState.moves.length === 0) {
                log('No moves to analyze yet', 'warning');
                return;
            }
            
            const lastMove = gameState.moves[gameState.moves.length - 1];
            log(`Manual tutoring requested for move ${lastMove.moveNumber}`, 'info');
            provideTutoring(lastMove);
        }

        // Update game information
        function updateGameInfo() {
            document.getElementById('move-count').textContent = gameState.moveCount;
            document.getElementById('current-turn').textContent = gameState.currentTurn.charAt(0).toUpperCase() + gameState.currentTurn.slice(1);
            
            // Update game mode
            const manualMode = document.getElementById('manual-mode').checked;
            const mode = gameState.monitoring ? (manualMode ? 'Manual + Monitor' : 'Monitoring') : (manualMode ? 'Manual Play' : 'Idle');
            document.getElementById('game-mode').textContent = mode;
            
            // Update board cursor style
            const board = document.getElementById('go-board');
            if (manualMode && !gameState.monitoring) {
                board.classList.add('manual-mode');
            } else {
                board.classList.remove('manual-mode');
            }
            
            // Update game phase
            if (gameState.moveCount < 30) {
                gameState.gamePhase = 'Opening';
            } else if (gameState.moveCount < 120) {
                gameState.gamePhase = 'Middle Game';
            } else {
                gameState.gamePhase = 'Endgame';
            }
            
            document.getElementById('game-phase').textContent = gameState.gamePhase;
            
            // Update opponent button
            updateOpponentButton();
        }

        // Provide AI tutoring
        function provideTutoring(lastMove) {
            log(`Providing AI tutoring for move ${lastMove.moveNumber}...`, 'info');
            
            // Simulate AI analysis
            const analysis = generateMockAnalysis(lastMove);
            displayTutoringMessage(analysis);
        }

        // Generate mock AI analysis
        function generateMockAnalysis(move) {
            const phase = gameState.gamePhase;
            
            return {
                move: move,
                phase: phase,
                hint: generateSimpleHint(phase, move.coordinate, gameState.moveCount)
            };
        }

        // Generate simple, focused hints
        function generateSimpleHint(phase, coordinate, moveCount) {
            const hints = {
                'Opening': [
                    "Secure corners first, then develop towards the center",
                    "Balance territory and influence in your moves", 
                    "Consider how your stones work together",
                    "Look for good extension points from your corner stones",
                    "Think about approaching opponent's corners"
                ],
                'Middle Game': [
                    "Look for weak groups that need attention",
                    "Consider attacking opponent's weak stones",
                    "Strengthen your own groups before attacking",
                    "Look for good invasion points",
                    "Connect your stones to build strong groups"
                ],
                'Endgame': [
                    "Look for the biggest point values on the board",
                    "Play sente moves that force opponent to respond", 
                    "Secure your territory boundaries",
                    "Count the score and play accordingly",
                    "Look for endgame tesuji opportunities"
                ]
            };
            
            const phaseHints = hints[phase] || hints['Opening'];
            return phaseHints[Math.floor(Math.random() * phaseHints.length)];
        }

        // Test function for debugging
        function testOpponent() {
            log('=== TESTING OPPONENT FUNCTION ===', 'info');
            log(`Move count: ${gameState.moveCount}`, 'info');
            log(`Current turn: ${gameState.currentTurn}`, 'info');
            log(`Manual mode: ${document.getElementById('manual-mode').checked}`, 'info');
            log(`Moves so far: ${gameState.moves.map(m => m.coordinate).join(', ')}`, 'info');
            
            if (gameState.moveCount === 0) {
                log('Adding test move first...', 'info');
                addMoveToGame('D4', 'black');
                return;
            }
            
            // Test move generation
            const testMove = generateOpponentMove();
            log(`Generated move: ${testMove}`, testMove ? 'success' : 'error');
            
            if (testMove) {
                log('Adding opponent move...', 'info');
                addMoveToGame(testMove, gameState.currentTurn);
            }
        }

        // Display tutoring message
        function displayTutoringMessage(analysis) {
            const content = document.getElementById('tutoring-content');
            
            const message = document.createElement('div');
            message.className = 'tutoring-message slide-in';
            
            message.innerHTML = `
                <h4>üéì Move ${analysis.move.moveNumber}: ${analysis.move.coordinate}</h4>
                
                <p><strong>üìä Phase:</strong> ${analysis.phase}</p>
                
                <p><strong>üí° Next Step:</strong> ${analysis.hint}</p>
            `;
            
            content.appendChild(message);
            
            // Scroll to bottom
            content.scrollTop = content.scrollHeight;
            
            // Limit number of messages
            const messages = content.querySelectorAll('.tutoring-message');
            if (messages.length > 8) {
                content.removeChild(messages[0]);
            }
        }

        // Update connection status
        function updateConnectionStatus(status) {
            const indicator = document.getElementById('connection-status');
            indicator.className = `status-indicator status-${status}`;
        }

        // Clear game
        function clearGame() {
            gameState.moves = [];
            gameState.moveCount = 0;
            gameState.gamePhase = 'Opening';
            gameState.currentTurn = 'black';
            
            // Clear board
            const board = document.getElementById('go-board');
            const stones = board.querySelectorAll('.stone');
            stones.forEach(stone => stone.remove());
            
            // Clear move history
            document.getElementById('move-list').innerHTML = '';
            
            // Clear tutoring content
            const content = document.getElementById('tutoring-content');
            content.innerHTML = `
                <div class="tutoring-message">
                    <h4>New Game Started! üéØ</h4>
                    <p><strong>üìä Phase:</strong> Opening</p>
                    <p><strong>üí° Next Step:</strong> Start with a corner move like D4, Q16, D16, or Q4</p>
                </div>
            `;
            
            updateGameInfo();
            log('New game started', 'success');
        }

        // Clear log
        function clearLog() {
            document.getElementById('log-content').innerHTML = '';
            log('Log cleared', 'info');
        }

        // Log function
        function log(message, type = 'info') {
            const logContent = document.getElementById('log-content');
            const timestamp = new Date().toLocaleTimeString();
            
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${timestamp}] ${message}`;
            
            logContent.appendChild(entry);
            logContent.scrollTop = logContent.scrollHeight;
            
            // Limit log entries
            const entries = logContent.querySelectorAll('.log-entry');
            if (entries.length > 50) {
                logContent.removeChild(entries[0]);
            }
        }
    </script>
</body>
</html>